import java.awt.geom.Point2D;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import org.simbrain.network.NetworkComponent;
import org.simbrain.network.connections.*;
import org.simbrain.network.core.*;
import org.simbrain.network.core.NeuronUpdateRule.InputType;
import org.simbrain.network.groups.*;
import org.simbrain.network.layouts.*;
import org.simbrain.network.desktop.*;
import org.simbrain.network.neuron_update_rules.*;
import org.simbrain.network.synapse_update_rules.*;
import org.simbrain.network.synapse_update_rules.spikeresponders.*;
import org.simbrain.world.odorworld.sensors.SmellSensor;
// import org.simbrain.custom_sims.helper_classes.AddSTDPRule;
// import org.simbrain.custom_sims.helper_classes.SORNNeuronRule;
import org.simbrain.network.update_actions.*;
import org.simbrain.util.randomizer.*;
import org.simbrain.util.*;
import org.simbrain.workspace.*;
import org.simbrain.util.SimbrainConstants.Polarity;
import javax.swing.JInternalFrame;
import org.simbrain.util.math.*;
import org.simbrain.workspace.*;
import org.simbrain.world.odorworld.*;
import org.simbrain.world.odorworld.entities.*;
import org.simbrain.util.environment.*;
import java.text.DecimalFormat;
import java.text.NumberFormat;

/**
 *
 * Creates a SORN: Self-Organizing Recurrent Network as described in:
 * Lazar, Pipa, & Triesch 2009. Inhibitory and excitatory neurons are
 * split into different groups here, so the reservoir is comprised of
 * two separate neuron groups. This is to allow for better control over
 * how excitatory and inhibitory neurons are connected. Inputs are
 * Poisson distributed spike trains in this demo.
 *
 * The hallmark of the SORN model are the 3 forms of plasticity
 * including neuronal homeostatic plasticity, spike-timing dependent
 * plasticity, and synaptic normalization.
 *
 * Note that this model uses custom classes in the SORN directory.
 * Compiled classes provide better performance.   To implement something similar
 * yourself you can use the SORN directory and its files as a template.
 * Compile the java classes directly in the sorn directory, and then refer
 * to them using the call to "addClassPath" below.
 *
 * The custom classes in the SORN directory extend an existing neuron
 * rule (SpikingThreshold) and synapse update rule (STDP).
 *
 * Like any liquid state machine (or most recurrent spiking neural networks
 * with rudimentary stabilizing mechansims) SORNs will encode temporal
 * information into the state of the reservoir at each time-step. SORNs
 * in particular do a very goood job of separating inputs, i.e. configuring
 * itself in such a way that different inputs tend to have very different
 * representations in terms of the state of the recurrent reservoir. The
 * increasing separation between patterns in the reservoir can be observed
 * as the network self-organizes via one of the dimensionality reduction
 * plots.
 *
 * To see this, give the SORN an input sequence which has some sort of structure,
 * that is, an input where the current input has some statistical relationship
 * to previous inputs, such that certain sequences of inputs make others more
 * or less likely.
 *
 * It is reccommended that one allows the SORN to self organize, then disables
 * at least STDP and Synaptic Normalization before training and testing a linear
 * classifier on the desired data.
 *
 */
{

    workspace.clearWorkspace();

    boolean homeoPlastic = true;
    boolean abridged = false;
    int NUM_NEURONS = 200; // originally 2500 w/ "// 1024" comment
    int GRID_SPACE = 25;
    int RADIUS = 400; // 100
    int EE_KIN = 10; // originally 25 (this is lambda_w)
    int IE_KIN = (int)(0.2 * NUM_NEURONS)/10;
    // int EI_KIN = NUM_NEURONS/50;
    int EI_KIN = 50;
    String bouncerDispersion = "20.00";
    double bouncerDispDouble = 20.00;
    double bouncerPeak = 15.0;
    double motionSpeed = 2.0;
    double smellCentreLength = 25.0;

    // My additions
    int NUM_INPUTS = 9; // 15; // was originally 200
    double TE_max = 0.75; // was originally 0.5
    double TI_max = 1.4; // was originally 0.8
    double n_STDP = 0.001; // STDP learning rate
    double time_step = 1.0; // 41.38; // each update in network advances time by 'time_step' (ms)
    double etaIP = 0.001;
    double numerator = 0.0;
    double denominator = Math.log10(2.0);
    NumberFormat doubleFormatter = new DecimalFormat("#0.00");

    // Add custom classes to classpath
    String FS = System.getProperty("file.separator");
    // System.out.print("CURRENT DIR: ");
    // System.out.println(System.getProperty("user.dir"));
    addClassPath("scripts" + FS + "scriptmenu" + FS + "SORN" );
    workspace.openWorkspace(new File("scripts" + FS + "scriptmenu" + FS + "SORNmodWithAbridgingSimplified.zip"));

    // for (int i = 0; i < skinReceptors.getNeuronList().size(); i++) {
    //   System.out.print("Receptor number ");
    //   System.out.println(i);
    // }
    // List<Neuron> receptorNeurons = skinReceptors.getNeuronList();

    // Build Network
    NetworkComponent networkComponent = new NetworkComponent("Network");
    workspace.addWorkspaceComponent(networkComponent);
    Network network = networkComponent.getNetwork();
    network.setTimeStep(time_step);



    // EXCITATORY NEURON RULE
    ArrayList<Neuron> neurons = new ArrayList<Neuron>();
    ArrayList<Neuron> inhibitoryNeurons = new ArrayList<Neuron>();
    SORNNeuronRule sornRule = new SORNNeuronRule();
    sornRule.sethIP((2*NUM_INPUTS)/NUM_NEURONS);
    for (int i = 0; i < NUM_NEURONS; i++) {
    	   Neuron n = new Neuron(network);
        sornRule.setMaxThreshold(TE_max);
        sornRule.setThreshold(TE_max * Math.random() + 0.01);
        sornRule.setRefractoryPeriod(1);
        sornRule.setAddNoise(true);
    	   n.setPolarity(Polarity.EXCITATORY);
        n.setUpdateRule(sornRule.deepCopy());
	   neurons.add(n);
    }

  // INHIBITORY NEURON RULE
	SORNNeuronRule str = new SORNNeuronRule();
    for (int i = 0; i < (int) (NUM_NEURONS * 0.2); i++) {
        Neuron n = new Neuron(network);
        str.setThreshold(TI_max * Math.random() + 0.01);
        str.setEtaIP(etaIP); // set to 0 for no homeostatic plasticity
        str.setRefractoryPeriod(1);
        str.setAddNoise(true);
        n.setPolarity(Polarity.INHIBITORY);
        n.setUpdateRule(str.deepCopy());
        inhibitoryNeurons.add(n);
    }

  // EXCITATORY NEURON GROUP
	NeuronGroup ng = new NeuronGroup(network, neurons);
	GridLayout layout = new GridLayout(GRID_SPACE, GRID_SPACE, (int) Math.sqrt(NUM_NEURONS));
  ng.setLabel("Excitatory");
  network.addGroup(ng);
  ng.setLayout(layout);
  ng.applyLayout(new Point(10, 10));
  // network.addGroup(skinReceptors);
  // network.addGroup(motionLogic);

  NeuronGroup ngIn = new NeuronGroup(network, inhibitoryNeurons);
  layout = new GridLayout(GRID_SPACE, GRID_SPACE, (int) Math.sqrt(0.2 * NUM_NEURONS));
  ngIn.setLabel("Inhibitory");
  network.addGroup(ngIn);
  ngIn.setLayout(layout);
  System.out.println(ngIn.size());
  int x_loc = (int) (Math.sqrt(NUM_NEURONS) * GRID_SPACE + 300);
  ngIn.applyLayout(new Point(x_loc, 10));

  PolarizedRandomizer exRand = new PolarizedRandomizer(Polarity.EXCITATORY,
	ProbDistribution.UNIFORM);
	PolarizedRandomizer inRand = new PolarizedRandomizer(Polarity.INHIBITORY,
	ProbDistribution.UNIFORM);
	exRand.setParam1(0);
	exRand.setParam2(1);
	inRand.setParam1(0);
	inRand.setParam2(1);

  RadialSimpleConstrainedKIn ee_con = new RadialSimpleConstrainedKIn(EE_KIN, RADIUS);
  SynapseGroup sg_ee = SynapseGroup.createSynapseGroup(ng, ng, ee_con, 1.0, exRand, inRand);
  System.out.println("Just created EE synapse group");
  sg_ee.setLabel("EE Synapses");
  sg_ee.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(sg_ee);

  RadialSimpleConstrainedKIn ie_con = new RadialSimpleConstrainedKIn(IE_KIN, 100000);
  SynapseGroup sg_ie = SynapseGroup.createSynapseGroup(ngIn, ng, ie_con, 1.0, exRand, inRand);
  System.out.println("Just created IE synapse group");
  sg_ie.setLabel("IE Synapses");
  sg_ie.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(sg_ie);

  RadialSimpleConstrainedKIn ei_con = new RadialSimpleConstrainedKIn(EI_KIN, 100000);
  SynapseGroup sg_ei = SynapseGroup.createSynapseGroup(ng, ngIn, ei_con, 1.0, exRand, inRand);
  System.out.println("Just created EI synapse group");
  sg_ei.setLabel("EI Synapses");
  sg_ei.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(sg_ei);

	for (Neuron n : neurons) {
		((SORNNeuronRule) n.getUpdateRule()).init(n);
	}

	AddSTDPRule stdp = new AddSTDPRule();
	stdp.setLearningRate(n_STDP);
	sg_ee.setLearningRule(stdp, Polarity.BOTH);

  ArrayList<Neuron> inNeurons = new ArrayList<Neuron>();
  for (int i = 0; i < NUM_INPUTS; i++) {
      Neuron n = new Neuron(network);
        //SpikingThresholdRule inRule = new SpikingThresholdRule();
      //inRule.setThreshold(0.96);
      sornRule.setMaxThreshold(TE_max);
      sornRule.setThreshold(TE_max * Math.random() + 0.01);
    	n.setPolarity(Polarity.EXCITATORY);
      n.setUpdateRule(sornRule.deepCopy());
      inNeurons.add(n);
  }


  NeuronGroup input = new NeuronGroup(network, inNeurons);
  // layout = new GridLayout(GRID_SPACE, GRID_SPACE, (int) Math.sqrt(0.4 * NUM_NEURONS));
  LineLayout line_layout = new LineLayout();
  input.setLabel("Input");
  network.addGroup(input);
  input.setLayout(line_layout);
  // Todo; get current location of ng above
  int y_loc = (int) (Math.sqrt(NUM_INPUTS) * GRID_SPACE + 200);
  input.applyLayout(new Point(x_loc, y_loc));

  Sparse input_ee_con = new Sparse(0.05, false, false); // first argument (density) was originally 0.05
  SynapseGroup input_ee = SynapseGroup.createSynapseGroup(input, ng, input_ee_con, 1.0, exRand, inRand);
  System.out.println("Just created input -> excitatory synapse group");
  input_ee.setLabel("Input -> Excitatory");
  input_ee.setLearningRule(stdp, Polarity.BOTH);
  input_ee.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(input_ee);

  Sparse ee_input_con = new Sparse(0.01, false, false); // first argument (density) was originally 0.01
  SynapseGroup ee_input = SynapseGroup.createSynapseGroup(ng, input, ee_input_con, 1.0, exRand, inRand);
  System.out.println("Just created excitatory -> input synapse group");
  ee_input.setLabel("Excitatory -> Input");
  ee_input.setLearningRule(stdp, Polarity.BOTH);
  ee_input.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(ee_input);

  Sparse input_ie_con = new Sparse(0.01, true, false); // first argument (density) was originally 0.01
  SynapseGroup input_ie = SynapseGroup.createSynapseGroup(input, ngIn, input_ie_con, 1.0, exRand, inRand);
  System.out.println("Just created input -> inhibitory synapse group");
  input_ie.setLabel("Input -> Inhibitory");
  input_ie.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(input_ie);

  Sparse ie_input_con = new Sparse(0.01, true, false); // first argument (density) was originally 0.01
  SynapseGroup ie_input = SynapseGroup.createSynapseGroup(ngIn, input, input_ie_con, 1.0, exRand, inRand);
  System.out.println("Just created inhibitory -> input synapse group");
  ie_input.setLabel("Inhibitory -> Input");
  ie_input.setSpikeResponder(new Step(), Polarity.BOTH);
  network.addGroup(ie_input);


  // workspace.coupleOneToOne(skinReceptorGroup.getPotentialProducers(), inputGroup.getPotentialConsumers());


	for (Neuron n : neurons) {
		n.normalizeInhibitoryFanIn();
	}
	for (Neuron n : inhibitoryNeurons) {
		n.normalizeExcitatoryFanIn();
	}

	for (Neuron n : input.getNeuronList()) {
		n.normalizeInhibitoryFanIn();
		n.normalizeExcitatoryFanIn();
	}

    network.getUpdateManager().clear();
    network.getUpdateManager().addAction(ConcurrentBufferedUpdate.createConcurrentBufferedUpdate(network));
    network.updateTimeType();


    Network motionNet = ((NetworkComponent) workspace.getComponent("Network2")).getNetwork();
    desktop.getDesktopComponent(workspace.getComponent("Network")).getParentFrame().setBounds(784, 0, 583, 402);
    OdorWorldComponent motionWorldComponent = (OdorWorldComponent) workspace.getComponent("oneObject.xml");
    // OdorWorld motionWorld = motionWorldComponent.getWorld();

    motionWorldComponent.setGuiOn(false);
    OdorWorld motionWorld = ((OdorWorldComponent) workspace.getComponent("oneObject.xml")).getWorld();
    // motionComponent = workspace.getComponent("oneObject.xml");

    OdorWorldEntity mouse = (OdorWorldEntity) motionWorld.getEntity("Entity_8");
    SmellSensor centreSmell = mouse.getSensor("Smell-Center");
    OdorWorldEntity leftCandle = (OdorWorldEntity) motionWorld.getEntity("Entity_9");
    OdorWorldEntity rightCandle = (OdorWorldEntity) motionWorld.getEntity("Entity_4");
    SmellSource leftBouncer = leftCandle.getSmellSource();
    SmellSource rightBouncer = rightCandle.getSmellSource();
    OdorWorldEntity abridgingEntity = (OdorWorldEntity) motionWorld.getEntity("Entity_15");
    SmellSource abridgingTrigger = abridgingEntity.getSmellSource();
    NetworkComponent motionComponent = workspace.getComponent("Network2");
    Neuron speedNeuron = motionNet.getNeuronByLabel("Speed");
    motionComponent.setGuiOn(true);
    // SORNNetwork has already been initialised as simply "network" and as a component "networkComponent"
    motionNet.setTimeStep(time_step);
    Group motionLogic = motionNet.getGroupByLabel("Motion logic");
    Group skinReceptors = motionNet.getGroupByLabel("Mechanoreceptors");
    Group inputNeurons = network.getGroupByLabel("Input");
    PotentialProducer receptorProducers = NetworkComponent.getNeuronGroupProducer(motionComponent, skinReceptors, "getExternalActivations");
    PotentialConsumer inputConsumers = NetworkComponent.getNeuronGroupConsumer(networkComponent, inputNeurons, "setInputValues");
    List<PotentialProducer> producers = new ArrayList<PotentialProducer>();
    producers.add(receptorProducers);
    List<PotentialConsumer> consumers = new ArrayList<PotentialConsumer>();
    consumers.add(inputConsumers);
    System.out.println("Successfully created producer and consumer");
    workspace.coupleOneToOne(producers, consumers);


    /* INTERACTION MODEL */
    JInternalFrame internalFrame = new JInternalFrame("Control panel", true, true);
    LabelledItemPanel panel = new LabelledItemPanel();
    JButton freezeNet = new JButton("Freeze");
    freezeNet.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        System.out.println("Weights should be frozen!");
        // motionNet.freezeSynapses(true);
        network.freezeSynapses(true);
      }
    });
    panel.addItem("Pause SORN", freezeNet);

    JButton unfreezeNet = new JButton("Unfreeze");
    unfreezeNet.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        System.out.println("Weights shouldn't be frozen any more!!!");
        // motionNet.freezeSynapses(false);
        network.freezeSynapses(false);
      }
    });
    panel.addItem("Resume SORN", unfreezeNet);

    JButton homeostaticPlasticity = new JButton("Toggle");
    homeostaticPlasticity.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        if (homeoPlastic == true) {
          homeoPlastic = false;
          str.setEtaIP(0);
          System.out.println("Turned homeostatic plasticity off");
        } else if (homeoPlastic == false) {
          homeoPlastic = true;
          str.setEtaIP(etaIP);
          System.out.println("Turned homeostatic plasticity on");
        }
      }
    });
    panel.addItem("Homeostatic plasticity", homeostaticPlasticity);

    JButton abridging = new JButton("Toggle");
    abridging.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        if (abridged == true) {
          abridged = false;
          abridgingTrigger.setStimulusS("0,0");
          bouncerDispDouble = bouncerDispDouble/2.0;
          System.out.println("Turned abridging off");
        } else if (abridged == false) {
          abridged = true;
          abridgingTrigger.setStimulusS("1,1");
          bouncerDispDouble = 2.0*bouncerDispDouble;
          System.out.println("Turned abridging on");
        }
        leftBouncer.setDispersion(bouncerDispDouble);
        rightBouncer.setDispersion(bouncerDispDouble);
      }
    });
    panel.addItem("Abridging", abridging);

    JTextField stimulusSpeed = new JTextField("2");
    panel.addItem("Brushing speed", stimulusSpeed);

    JButton setSpeed = new JButton("OK");
    setSpeed.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        motionSpeed = Double.parseDouble(stimulusSpeed.getText());
        if (motionSpeed > 2.0) {
          smellCentreLength = 25.0 + (motionSpeed/2.0);
          bouncerPeak = smellCentreLength - 5.0;
        } else {
          smellCentreLength = 25.0;
          bouncerPeak = 15.0;
        }

        centreSmell.setRadius(smellCentreLength);
        speedNeuron.getUpdateRule().setBias(motionSpeed);
        // we want to set the dispersion of the candles to something like 10*log2(speed)
        // Java only has logE, log10, so we'll have to do change of base (i.e. 10*(log10(speed)/log10(2)))
        numerator = Math.log10(motionSpeed);

        bouncerDispersion = doubleFormatter.format(10*(numerator/denominator));
        bouncerDispDouble = (abridged ? 2 : 1)*Double.parseDouble(bouncerDispersion);
        leftBouncer.setDispersion(bouncerDispDouble);
        rightBouncer.setDispersion(bouncerDispDouble);
        leftBouncer.setPeak(bouncerPeak);
        rightBouncer.setPeak(bouncerPeak);
        workspace.iterate();
      }
    });
    panel.setMyNextItemRow(4);
    panel.addItem("", setSpeed, 1);


    internalFrame.setLocation(0,0);
    internalFrame.getContentPane().add(panel);
    internalFrame.setVisible(true);
    internalFrame.pack();
    desktop.addInternalFrame(internalFrame);

    /***************************************
    **** SCRAMBLING ************************
    ***************************************/
    int numTargets = 6;
    int targetSize = 50; // square
    int movementFactor = 1; // stimulus moves in discrete steps of one target at a time; since motion is continuous in experiment, this is not realistic
    int startLocation = (targetSize * numTargets) - targetSize / 2;
    boolean stop = false;
    OdorWorld scramblingWorld;
    OdorWorldBuilder scramblingOb;
    RotatingEntity stimulus;

  workspace.addWorkspaceComponent(new OdorWorldComponent("Scrambling stimulus")); 
}
